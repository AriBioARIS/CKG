"""
    **grapher.py**
    Populates the graph database with all the files generated by the importer.py module: 
    Ontologies, Databases and Experiments.
    The module loads all the entities and relationships defined in the importer files. It
    calls Cypher queries defined in the cypher.py module. Further, it generates an hdf object
    with the number of enities and relationships loaded for each Database, Ontology and Experiment.
    This module also generates a compressed backup file of all the loaded files.
    There are two types of updates: 
    - Full: all the entities and relationships in the graph database are populated
    - Partial: only the specified entities and relationships are loaded
    The compressed files for each type of update are named accordingly and saved in the archive/ folder
    in data/.
"""
import os
import sys
from datetime import datetime
import config.ckg_config as ckg_config
import ckg_utils
from graphdb_connector import connector
from graphdb_builder import builder_utils
import logging
import logging.config

log_config = ckg_config.graphdb_builder_log
logger = builder_utils.setup_logging(log_config, key="grapher")
START_TIME = datetime.now()

try:
    config = ckg_utils.get_configuration(ckg_config.builder_config_file)
except Exception as err:
    logger.error("Reading configuration > {}.".format(err))

def load_into_database(driver, queries, requester):
    for query in queries:
        try:
            result = connector.sendQuery(driver, query+";").data()
            if len(result) > 0:
                counts = result.pop()
                if 0 in counts.values():
                    logger.warning("{} - No data was inserted in query: {}.\n results: {}".format(requester, query, counts))

                logger.info("{} - cypher query: {}.\n results: {}".format(requester, query, counts))
            else:
                logger.info("{} - cypher query: {}".format(requester, query))
        except Exception as err:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            raise Exception("{}, file: {}, line: {}.\n Query: {}".format(err, fname, exc_tb.tb_lineno, query))        
    
    return result

def updateDB(driver, imports=None):
    """
    Populates the graph database with information for each Database, Ontology or Experiment
    specified in imports. If imports is not defined, the function populates the entire graph 
    database based on the graph variable defined in the grapher_config.py module.
    This function also updates the graph stats object with numbers from the loaded entities and
    relationships.
    Args:
        driver (py2neo driver): py2neo driver, which provides the 
                                connection to the neo4j graph database
        imports (list): A list of entities to be loaded into the graph
    """
    if imports is None:
        imports = config["graph"]

    try:
        cypher_queries = ckg_utils.get_queries(config['cypher_queries_file'])
    except Exception as err:
        logger.error("Reading queries file > {}.".format(err))
        
    for i in imports:
        queries = []
        logger.info("Loading {} into the database".format(i))
        try:
            importDir = os.path.join(os.getcwd(),config["databasesDirectory"])
            #Ontologies
            if "ontologies" == i:
                entities = config["ontology_entities"]
                importDir = os.path.join(os.getcwd(), config["ontologiesDirectory"])
                ontologyDataImportCode = cypher_queries['IMPORT_ONTOLOGY_DATA']['query']
                for entity in entities:
                    queries.extend(ontologyDataImportCode.replace("ENTITY", entity).replace("IMPORTDIR", importDir).split(';')[0:-1])
            #Databases
            #Chromosomes
            elif "chromosomes" == i:
                chromosomeDataImportCode = cypher_queries['IMPORT_CHROMOSOME_DATA']['query']
                queries = chromosomeDataImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Genes
            elif "genes" == i:
                geneDataImportCode = cypher_queries['IMPORT_GENE_DATA']['query']
                queries = geneDataImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Transcripts
            elif "transcripts" == i:
                transcriptDataImportCode = cypher_queries['IMPORT_TRANSCRIPT_DATA']['query']
                queries = transcriptDataImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Proteins
            elif "proteins" == i:
                proteinDataImportCode = cypher_queries['IMPORT_PROTEIN_DATA']['query']
                queries = proteinDataImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Protein annotations
            elif "annotations" == i:
                proteinAnnotationsImportCode = cypher_queries['IMPORT_PROTEIN_ANNOTATIONS']['query']
                queries = proteinAnnotationsImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Protein complexes
            elif "complexes" == i:
                complexDataImportCode = cypher_queries['IMPORT_COMPLEXES']['query']
                for resource in config["complexes_resources"]:
                    queries.extend(complexDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Modified proteins
            elif "modified_proteins" == i:
                modified_proteinsImportCode = cypher_queries['IMPORT_MODIFIED_PROTEINS']['query']
                for resource in config["modified_proteins_resources"]:
                    queries.extend(modified_proteinsImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
                modified_proteins_annotationsImportCode = cypher_queries['IMPORT_MODIFIED_PROTEIN_ANNOTATIONS']['query']
                for resource in config["modified_proteins_resources"]:
                    queries.extend(modified_proteins_annotationsImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Pathology expression
            elif "pathology_expression" == i:
                pathology_expression_DataImportCode = cypher_queries['IMPORT_PATHOLOGY_EXPRESSION']['query']
                for resource in config["pathology_expression_resources"]:
                    queries.extend(pathology_expression_DataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #PPIs
            elif "ppi" == i:
                ppiDataImportCode = cypher_queries['IMPORT_CURATED_PPI_DATA']['query']
                for resource in config["curated_PPI_resources"]:
                    queries.extend(ppiDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
                ppiDataImportCode = cypher_queries['IMPORT_COMPILED_PPI_DATA']['query']
                for resource in config["compiled_PPI_resources"]:
                    queries.extend(ppiDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
                ppiDataImportCode = cypher_queries['IMPORT_PPI_ACTION']['query']
                for resource in config["PPI_action_resources"]:
                    queries.extend(ppiDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Diseases
            elif "diseases" == i:
                diseaseDataImportCode = cypher_queries['IMPORT_DISEASE_DATA']['query']
                for entity, resource in config["disease_resources"]:
                    queries.extend(diseaseDataImportCode.replace("IMPORTDIR", importDir).replace("ENTITY", entity).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Drugs  
            elif "drugs" == i:
                drugsDataImportCode = cypher_queries['IMPORT_DRUG_DATA']['query']
                queries = drugsDataImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
                drugsDataImportCode = cypher_queries['IMPORT_CURATED_DRUG_DATA']['query']
                for resource in config["curated_drug_resources"]:
                    queries.extend(drugsDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
                drugsDataImportCode = cypher_queries['IMPORT_COMPILED_DRUG_DATA']['query']
                for resource in config["compiled_drug_resources"]:
                    queries.extend(drugsDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
                drugsDataImportCode = cypher_queries['IMPORT_DRUG_ACTS_ON']['query']
                for resource in config["drug_action_resources"]:
                    queries.extend(drugsDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Side effects
            elif "side effects" == i:
                sideEffectsDataImportCode = cypher_queries['IMPORT_DRUG_SIDE_EFFECTS']['query']
                for resource in config["side_effects_resources"]:
                    queries.extend(sideEffectsDataImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Pathway
            elif 'pathway' == i:
                pathwayImportCode = cypher_queries['IMPORT_PATHWAY_DATA']['query']
                for resource in config["pathway_resources"]:
                    queries.extend(pathwayImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Metabolite
            elif 'metabolite' == i:
                metaboliteImportCode = cypher_queries['IMPORT_METABOLITE_DATA']['query']
                for resource in config["metabolite_resources"]:
                    queries.extend(metaboliteImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Food
            elif 'food' == i:
                foodImportCode = cypher_queries['IMPORT_FOOD_DATA']['query']
                for resource in config["food_resources"]:
                    queries.extend(foodImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #GWAS
            elif "gwas" == i:
                code = cypher_queries['IMPORT_GWAS']['query']
                queries = code.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Known variants
            elif "known_variants" == i:
                variantsImportCode = cypher_queries['IMPORT_KNOWN_VARIANT_DATA']['query']
                queries = variantsImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
            #Clinically_relevant_variants
            elif "clinical variants" == i:
                variantsImportCode = cypher_queries['IMPORT_CLINICALLY_RELEVANT_VARIANT_DATA']['query']
                for resource in config["clinical_variant_resources"]:
                    queries.extend(variantsImportCode.replace("IMPORTDIR", importDir).replace("RESOURCE", resource.lower()).split(';')[0:-1])
            #Internal
            elif "internal" == i:
                internalDataImportCode = cypher_queries['IMPORT_INTERNAL_DATA']['query']
                for (entity1, entity2) in config["internalEntities"]:
                    queries.extend(internalDataImportCode.replace("IMPORTDIR", importDir).replace("ENTITY1", entity1).replace("ENTITY2", entity2).split(';')[0:-1])
            #Mentions
            elif "mentions" == i:
                publicationsImportCode = cypher_queries['CREATE_PUBLICATIONS']['query']
                queries = publicationsImportCode.replace("IMPORTDIR", importDir).split(';')[0:-1]
                mentionsImportCode = cypher_queries['IMPORT_MENTIONS']['query']
                for entity in config["mentionEntities"]:
                    queries.extend(mentionsImportCode.replace("IMPORTDIR", importDir).replace("ENTITY", entity).split(';')[0:-1])
             #Published in
            elif "published" == i:
                publicationImportCode = cypher_queries['IMPORT_PUBLISHED_IN']['query']
                for entity in config["publicationEntities"]:
                    queries.extend(publicationImportCode.replace("IMPORTDIR", importDir).replace("ENTITY", entity).split(';')[0:-1])
            #Projects
            elif "project" == i:
                importDir = os.path.join(os.getcwd(),config["experimentsDirectory"])
                projects = builder_utils.listDirectoryFolders(importDir)
                project_cypher = cypher_queries['IMPORT_PROJECT']
                for project in projects:
                    projectDir = os.path.join(importDir, project)
                    for project_section in project_cypher:
                        code = project_section['query']
                        queries.extend(code.replace("IMPORTDIR", projectDir).replace('PROJECTID', project).split(';')[0:-1])
            #Datasets
            elif "experiment" == i:
                importDir = os.path.join(os.getcwd(),config["experimentsDirectory"])
                datasets_cypher = cypher_queries['IMPORT_DATASETS']
                projects = builder_utils.listDirectoryFolders(importDir)
                for project in projects:
                    projectDir = os.path.join(importDir, project)
                    datasetTypes = builder_utils.listDirectoryFolders(projectDir)
                    for dtype in datasetTypes:
                        datasetDir = os.path.join(projectDir, dtype)
                        dataset = datasets_cypher[dtype]
                        code = dataset['query']
                        queries.extend(code.replace("IMPORTDIR", datasetDir).replace('PROJECTID', project).split(';')[0:-1])
            else:
                logger.error("Non-existing dataset. The dataset you are trying to import does not exist: {}.".format(i))
            load_into_database(driver, queries, i)
        except Exception as err:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error("Loading: {}: {}, file: {}, line: {}".format(i, err, fname, exc_tb.tb_lineno))

def fullUpdate():
    """
    Main method that controls the population of the graph database. Firstly, it gets a connection
    to the database (driver) and then initiates the update of the entire database getting
    all the graph entities to update from configuration. Once the graph database has been 
    populated, the imports folder in data/ is compressed and archived in the archive/ folder
    so that a backup of the imports files is kept (full).
    """
    imports = config["graph"]
    driver = connector.getGraphDatabaseConnectionConfiguration()
    logger.info("Full update of the database - Updating: {}".format(",".join(imports)))
    updateDB(driver, imports)
    logger.info("Full update of the database - Update took: {}".format(datetime.now() - START_TIME))
    logger.info("Full update of the database - Archiving imports folder")
    archiveImportDirectory(archive_type="full")
    logger.info("Full update of the database - Archiving took: {}".format(datetime.now() - START_TIME))

def partialUpdate(imports):
    """
    Method that controls the update of the graph database with the specified entities and 
    relationships. Firstly, it gets a connection
    to the database (driver) and then initiates the update of the specified graph entities. 
    Once the graph database has been populated, the data files uploaded to the graph are compressed 
    and archived in the archive/ folder (partial).
    Args:
        imports (list): list of entities to update
    """
    driver = connector.getGraphDatabaseConnectionConfiguration()
    logger.info("Partial update of the database - Updating: {}".format(",".join(imports)))
    updateDB(driver, imports)
    logger.info("Partial update of the database - Update took: {}".format(datetime.now() - START_TIME))
    logger.info("Partial update of the database - Archiving imports folder")
    #archiveImportDirectory(archive_type="partial")
    logger.info("Partial update of the database - Archiving {} took: {}".format(",".join(imports), datetime.now() - START_TIME))
    
def archiveImportDirectory(archive_type="full"):
    """
    This function creates the compressed backup imports folder with either the whole folder
    (full update) or with only the files uploaded (partial update). The folder or files are
    compressed into a gzipped tarball file and stored in the archive/ folder defined in the 
    configuration.
    Args:
        archive_type (string): whether it is a full update or a partial update
    """
    dest_folder = config["archiveDirectory"]
    builder_utils.checkDirectory(dest_folder)
    folder_to_backup = config["importDirectory"]
    date, time = builder_utils.getCurrentTime()
    file_name = "{}_{}_{}".format(archive_type, date.replace('-', ''), time.replace(':', ''))
    logger.info("Archiving {} to file: {}".format(folder_to_backup, file_name))
    builder_utils.compress_directory(folder_to_backup, dest_folder, file_name)
    logger.info("New backup created: {}".format(file_name))

if __name__ == "__main__":
    fullUpdate()
    #partialUpdate(imports=["mentions"])


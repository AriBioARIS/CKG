attributes:
    name: project information
    description: 'Gets all the attributes of a given Project. Requires: Project.id'
    involved_nodes:
        - Project
    involved_rels:
    query: >
        MATCH (project:Project)
        WITH project, size((project)-[]->()) AS number_subjects
        WHERE project.id="PROJECTID"
        RETURN project.id AS identifier, project.name AS name, project.acronym AS acronym,
        project.type AS data_types, project.responsible AS responsible, project.description AS description, number_subjects, project.status AS status;
extract_projectID:
    name: project identifier
    description: 'Returns project external identifier. Requires internal identifier.'
    involved_nodes:
        - Project
    involved_rels:
    query: >
        MATCH (p:Project)
        WHERE p.internal_id = "INTERNALID"
        RETURN p.id;
similarity:
    name: pearson_similarity
    description: The Pearson Similarity function computes the similarity of two given projects based on the proteins identified.
    involved_nodes:
        - Project
        - Protein
    involved_rels:
        - HAS_QUANTIFIED_PROTEIN
    query: >
        MATCH (project1:Project{id:'PROJECTID'})-[]-(:Subject)-[]-(:Biological_sample)-[]-(a:Analytical_sample)-[r:HAS_QUANTIFIED_PROTEIN]->(protein:Protein) 
        WHERE toBoolean(r.is_razor)
        WITH project1, algo.similarity.asVector(protein, r.value) AS p1Vector
        MATCH (project2:Project)-[]-(:Subject)-[]-(:Biological_sample)-[]-(a:Analytical_sample)-[r:HAS_QUANTIFIED_PROTEIN]->(protein:Protein) WHERE toBoolean(r.is_razor) AND project1 <> project2
        WITH project1, project2, p1Vector, algo.similarity.asVector(protein, r.value) AS p2Vector
        RETURN project1.name AS from, project2.name AS to, project2.description AS description, project2.responsible AS responsible, algo.similarity.pearson(p1Vector, p2Vector, {vectorType: "maps"}) AS similarity ORDER BY similarity DESC
overlap_measure:
    name: overlap_similarity
    description: Get overlap of entities between projects i.e. ENTITY = Biological_process, RELATIONSHIP = ASSOCIATED_WITH
    involved_nodes:
        - Project
    involved_rels:
    query: >
        MATCH (project:Project)-[]-(:Subject)-[]-(:Biological_sample)-[]-(a:Analytical_sample)-[r:HAS_QUANTIFIED_PROTEIN]->(protein:Protein)-[:RELATIONSHIP]-(entity:ENTITY) 
        WHERE toBoolean(r.is_razor)
        WITH {item:id(project), categories: collect(DISTINCT id(entity))} as projectData
        WITH collect(projectData) as data
        CALL algo.similarity.overlap.stream(data)
        YIELD item1, item2, count1, count2, intersection, similarity
        MATCH (from:Project) WHERE id(from)=item1
        WITH from, item2, count1, count2, intersection, similarity
        MATCH (to:Project) WHERE id(to)=item2
        RETURN from.id, to.id, count1, count2, intersection, similarity ORDER BY similarity DESC
